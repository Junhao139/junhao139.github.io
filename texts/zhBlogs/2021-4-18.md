# 闲聊

真就只是闲聊。

### C++，冷暖共存

不知道为何，感觉 C++ 的标准库如此丰富，就如在严寒中被给予一丝温暖般，助我在 C++ 编程的道路上渐行渐远。相较之下（不用比较也一样），C 语言，虽然也有挺多的标准库函数，但似乎缺少类的存在使它不是很贴合人类（OOP 程序员，夸大了夸大了）的思维习惯。其实本来我也疑问模板库和一部分标准库为何会很被需要（尽管之前我经常使用 std::vector 和 std::chrono），直到今天被迫使用了长时间的 string。C++ 由于数据和函数都可以被类封装，使它们用起来就像一个个活生生的人一样，各自做着自己的工作，各自拥有自己的特色。

若干月前，我从历史课本上稍微了解了欧洲的工业化时期（加泰罗尼亚的近代史书，主要就是讲欧洲），并知道了“泰勒主义”，又名“科学管理”或后来衍生的“福特主义”。旨对于流水线内的不同工作，只招熟悉该部分工作的人，提高生产速度，降低生产成本。

因此，面向对象编程就是一种符合人类管理思维逻辑的模式。其实，若非要用一个非 OOP 语言写大型项目的话，比如说 C，那么为了更好地管理，会使整个代码风格偏向 OOP 的编程思想，尽管不能完全实现数据隐藏。

> 如果要写一个主玩家与很多敌人之间对战的游戏，强制使用 C，一般的 Coder 会怎么想？

我想应该是这样吧？——

```c
typedef struct PlayerInfo {
    short X;
    short Y;
};

typedef struct EnemyInfo {
    short X;
    short Y;
};
```

你可能会说，我就不能在 main（或其它位置）定义两个分别存储 X 和 Y 的数组？

> 想法不错，逻辑也好像没什么问题。但不是最好的方法。
>
> 我知道，你这样的好处可能是减少内存占用（？），但实际只会增加代码。首先，敌人不只有一个，因此你需要对数组进行各种操作，比如“压入（向最后添加新元素）”，“弹出（删除最后元素）”…… 其次，大多数情况下，你不会只想要存 X 和 Y，还可能会有其它的信息，比如血条，弹药量，防御力，等等。这时候，
>
> - 你只能为**每一个数组写一遍实现同样功能的代码**，因为你需要确保任何一个数组发生了位置修改，都必须也使其它数组进行移位，以保证读取顺利；
> - 但凡你要使用**动态内存分配**，那就是成倍的 malloc。

缺点也许不止这些，但！用了 struct，你的难题将迎刃而解。当然，除非您计算机天资过人，且您的开发团队里都是像您一样在计算机方面天资过人的才华人士。

### 继续

这时候当然就是按功能造函数了。尽管 C 语言并不自带 OOP，但起码函数所起到的“分而治之”的功能还是需要实现的。这时候结构体的作用再次体现出来了：

```c
void myFunction(int X, int Y) {}
```

和

```c
void myFunction(PlayerInfo const* playerInfo) {}
```

相比，到底哪种方法更能减少精力，一目了然，高下立判。

> 之所以这么写（`PlayerInfo const* playerInfo`），是因为用作对比的代码也并未修改任何实际值，所以，**在无需修改原值的情况下，最好将指针声明为指向 const 数据，以防止数据篡改**。

对了，这里跟大家说一个小 tip，也和我为什么把 const 放到“奇怪”的地方有关系：

> `const` 会优先对其左面的东西产生作用，在左面没有符合条件的类型后，才会对右面的东西产生作用。

在这里，它先对 PlayerInfo 产生作用，就代表这个指针的“PlayerInfo 是不可修改的”，且不对 `*`产生作用，因此这个指针值是可以被修改的。

### 小结

越往下挖，非结构体的方法就越处在劣势地位。

struct 算是 OOP 的雏形，做到了数据统一存储，但没做到数据隐藏和方法整合。不过，光是包装了 struct 这一层，就能带来感知强烈的使用体验增加，更不用说继续向上包装的 OOP 思想了。

感觉刚才的最后一段有点偏题，但确实是很实用的小 Tip。感谢阅读。

### 又是一个周一！哈哈哈（孩子没救了）